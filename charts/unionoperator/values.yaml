# Default values for union-operator.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
union:
  # -- Mark cluster as healthy and ready to accept incoming workflows
  enabled: true
  # -- Enable the usage of tunnel service using cloudflare tunnels. This works only if the union services has this service enabled.
  enableTunnelService: false
  # -- Enable the usage of app service using cloudflare tunnels.
  enableAppService: false
  cloudUrl: "<Union Cloud URL>"
  appId: "<App Id from uctl create app>"
  metadataBucketPrefix: s3://my-s3-bucket
  clusterName: ""
  # Something like 'iam.gke.io/gcp-service-account' for GCP or 'eks.amazonaws.com/role-arn' for AWS
  userRoleAnnotationKey: "foo"
  # Flyte user role with permissions to patch onto project service accounts e.g. arn:aws:iam::ACCOUNT_ID:role/flyte_project_role
  userRoleAnnotationValue: "bar"
  collectUsages:
    enabled: true
  syncClusterConfig:
    enabled: true
  #
  # STORAGE SETTINGS
  #

  storage:
    # -- Sets the storage type. Supported values are sandbox, s3, gcs and custom.
    type: sandbox
    bucketName: my-s3-bucket-prod
    # -- settings for storage type s3
    s3:
      region: us-east-1
    # -- settings for storage type gcs
    gcs:
    # -- GCP project ID. Required for storage type gcs.
    # projectId:
    # -- Settings for storage type custom. See https://github:com/graymeta/stow for supported storage providers/settings.
    custom: { }

  secrets:
    # Okta application secret managed by union-base helm chart.
    create: false
    adminOauthClientCredentials:
      secretName: union-base
      # Intentionally empty to prevent secret creation
      clientSecret: ""

  resourcequotas:
    create: false

  flyteadmin:
    enabled: false
    image:
      repository: public.ecr.aws/unionai-flyte/flyteadmin
      tag: 2024.12.2

  flytescheduler:
    enabled: false
  flyteconsole:
    enabled: false
  datacatalog:
    enabled: false
  cacheservice:
    enabled: false

  #
  # FLYTEPROPELLER SETTINGS
  #

  flytepropeller:
    enabled: true
    priorityClassName: "system-cluster-critical"
    # -- Replicas count for Flytepropeller deployment
    replicaCount: 1
    # -- Default resources requests and limits for Flytepropeller deployment
    resources:
      limits:
        cpu: "4"
        ephemeral-storage: 500Mi
        memory: "8Gi"
      requests:
        cpu: "3000m"
        ephemeral-storage: 100Mi
        memory: "4Gi"
    cacheSizeMbs: 0
    client_secret: foobar
    # -- Default regex string for searching configuration files
    configPath: /etc/flyte/config/*.yaml

    # -- Configuration for service accounts for FlytePropeller
    serviceAccount:
      # -- Should a service account be created for FlytePropeller
      create: true
      # -- Annotations for ServiceAccount attached to FlytePropeller pods
      annotations: { }
      # -- ImapgePullSecrets to automatically assign to the service account
      imagePullSecrets: []
    # -- Annotations for Flytepropeller pods
    podAnnotations: { }
    # -- nodeSelector for Flytepropeller deployment
    nodeSelector: { }
    # -- tolerations for Flytepropeller deployment
    tolerations: [ ]
    # -- affinity for Flytepropeller deployment
    affinity: { }
    clusterName: '{{ include "getClusterName" . }}'
    image:
      repository: public.ecr.aws/p0i0a9q8/unionoperator
      tag: 2024.12.2
    service:
      enabled: true
      additionalPorts:
        - name: fasttask
          port: 15605
          targetPort: 15605
          protocol: TCP
    podEnv:
      - name: GOMEMLIMIT
        valueFrom:
          resourceFieldRef:
            resource: limits.memory
      - name: GOMAXPROCS
        valueFrom:
          resourceFieldRef:
            resource: limits.cpu
  #
  #
  # CLUSTER RESOURCE MANAGER (SYNC) SETTINGS
  #
  # Be sure to update deploy/tenant/helm/values-eks.yaml after modifications to this section.
  # See https://github.com/unionai/cloud/pull/7497 for more information.
  cluster_resource_manager:
    enabled: true
    unionCallbackEnabled: true
    standalone_deploy: true
    service_account_name: clustersync-resource
    rootCommand: clusterresource
    image:
      repository: public.ecr.aws/p0i0a9q8/unionoperator
      tag: 2024.12.2
    config:
      cluster_resources:
        standaloneDeployment: true
        customData:
          - production:
              - projectQuotaCpu:
                  value: "4096"
              - projectQuotaMemory:
                  value: "2Ti"
              - projectQuotaNvidiaGpu:
                  value: "256"
              - defaultUserRoleKey:
                  value: '{{ tpl .Values.userRoleAnnotationKey . }}'
              - defaultUserRoleValue:
                  value: '{{ tpl .Values.userRoleAnnotationValue . }}'
          - staging:
              - projectQuotaCpu:
                  value: "4096"
              - projectQuotaMemory:
                  value: "2Ti"
              - projectQuotaNvidiaGpu:
                  value: "256"
              - defaultUserRoleKey:
                  value: '{{ tpl .Values.userRoleAnnotationKey . }}'
              - defaultUserRoleValue:
                  value: '{{ tpl .Values.userRoleAnnotationValue . }}'
          - development:
              - projectQuotaCpu:
                  value: "4096"
              - projectQuotaMemory:
                  value: "2Ti"
              - projectQuotaNvidiaGpu:
                  value: "256"
              - defaultUserRoleKey:
                  value: '{{ tpl .Values.userRoleAnnotationKey . }}'
              - defaultUserRoleValue:
                  value: '{{ tpl .Values.userRoleAnnotationValue . }}'
        clusterName: '{{ include "getClusterName" . }}'
      clusterResourcesPrivate:
        app:
          isSelfServe: false
      union:
        connection:
          host: '{{- printf "dns:///%s" (.Values.cloudUrl | trimPrefix "dns:///" | trimPrefix "http://" | trimPrefix "https://") -}}'
        auth:
          type: ClientSecret
          clientId: '{{ tpl .Values.appId . }}'
          clientSecretLocation: /etc/union/secret/app_secret
          authorizationMetadataKey: "flyte-authorization"
          tokenRefreshWindow: 5m
    secretName: union-base
    templates:
      # -- Template for namespaces resources
      - key: a_namespace.yaml
        value: |
          apiVersion: v1
          kind: Namespace
          metadata:
            name: {{ namespace }}
            labels:
              union.ai/namespace-type: flyte
          spec:
            finalizers:
            - kubernetes

      # -- Patch default service account
      - key: b_default_service_account.yaml
        value: |
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: default
            namespace: {{ namespace }}
            annotations:
              {{ defaultUserRoleKey }}: {{ defaultUserRoleValue }}

      - key: c_project_resource_quota.yaml
        value: |
          apiVersion: v1
          kind: ResourceQuota
          metadata:
            name: project-quota
            namespace: {{ namespace }}
          spec:
            hard:
              limits.cpu: {{ projectQuotaCpu }}
              limits.memory: {{ projectQuotaMemory }}
              requests.nvidia.com/gpu: {{ projectQuotaNvidiaGpu }}
    resources:
      limits:
        cpu: "1"
        memory: "500Mi"
      requests:
        cpu: "500m"
        memory: "100Mi"
    prometheus:
      enabled: true
    podEnv:
      - name: GOMEMLIMIT
        valueFrom:
          resourceFieldRef:
            resource: limits.memory
      - name: GOMAXPROCS
        valueFrom:
          resourceFieldRef:
            resource: limits.cpu

  #
  # WEBHOOK SETTINGS
  #

  webhook:
    # -- enable or disable secrets webhook
    enabled: true
    # -- Configuration for service accounts for the webhook
    serviceAccount:
      # -- Should a service account be created for the webhook
      create: true
      # -- Annotations for ServiceAccount attached to the webhook
      annotations: { }
      # -- ImapgePullSecrets to automatically assign to the service account
      imagePullSecrets: []
    # -- Annotations for webhook pods
    podAnnotations: { }
    # -- Service settings for the webhook
    service:
      annotations:
        projectcontour.io/upstream-protocol.h2c: grpc
      type: ClusterIP
    podEnv:
      - name: GOMEMLIMIT
        valueFrom:
          resourceFieldRef:
            resource: limits.memory
      - name: GOMAXPROCS
        valueFrom:
          resourceFieldRef:
            resource: limits.cpu

  # --------------------------------------------------------------------
  # Specializing your deployment using configuration
  # -------------------------------------------------------------------
  #
  # CONFIGMAPS SETTINGS
  #

  configmap:
    # -- Admin Client configuration [structure](https://pkg.go.dev/github.com/flyteorg/flytepropeller/pkg/controller/nodes/subworkflow/launchplan#AdminConfig)
    admin:
      event:
        type: admin
        rate: 500
        capacity: 1000
      admin:
        endpoint: '{{- printf "dns:///%s" (.Values.cloudUrl | trimPrefix "dns:///" | trimPrefix "http://" | trimPrefix "https://") -}}'
        clientId: '{{ tpl .Values.appId . }}'
        clientSecretLocation: /etc/secrets/client_secret
        insecure: false
    # -- Catalog Client configuration [structure](https://pkg.go.dev/github.com/flyteorg/flytepropeller/pkg/controller/nodes/task/catalog#Config)
    # Additional advanced Catalog configuration [here](https://pkg.go.dev/github.com/lyft/flyteplugins/go/tasks/pluginmachinery/catalog#Config)
    catalog:
      catalog-cache:
        cache-endpoint: '{{- printf "dns:///%s" (.Values.cloudUrl | trimPrefix "dns:///" | trimPrefix "http://" | trimPrefix "https://") -}}'
        endpoint: '{{- printf "dns:///%s" (.Values.cloudUrl | trimPrefix "dns:///" | trimPrefix "http://" | trimPrefix "https://") -}}'
        type: fallback
        insecure: false
        use-admin-auth: true

    copilot:
      plugins:
        k8s:
          co-pilot:
            image: public.ecr.aws/unionai-flyte/flytecopilot:invalid-version
            name: flyte-copilot-
            start-timeout: 30s

    # -- Core propeller configuration
    core:
      manager:
        shard:
          type: Hash     # use the "hash" shard strategy
          shard-count: 3 # the total number of shards
      # -- Propeller config specified [here](https://pkg.go.dev/github.com/flyteorg/flytepropeller/pkg/controller/config).
      # These values are chosen to match a mix of [propeller config defaults](https://github.com/flyteorg/flytepropeller/blob/cbfcdf3396346bf83bd8e885d21803a5e53108ee/pkg/controller/config/config.go#L51-L114)
      # (many of which are overridden in the Chart's [values.yaml](https://github.com/flyteorg/flyte/blob/e6fa8120dc0be4c46e789270c89fcfef3f6289f9/charts/flyte-core/values.yaml#L671-L703)),
      # along with cloud-specific settings from [here](https://github.com/flyteorg/flyte/blob/e6fa8120dc0be4c46e789270c89fcfef3f6289f9/charts/flyte-core/values-eks.yaml#L233-L246).
      propeller:
        rawoutput-prefix: '{{ tpl .Values.metadataBucketPrefix $ }}'
        workers: 100
        max-workflow-retries: 50
        leader-election:
          enabled: false
        queue:
          type: batch
          batching-interval: 1s
          batch-size: -1
          queue:
            type: maxof
            base-delay: 0s
            max-delay: 60s
            rate: 1000
            capacity: 10000
          sub-queue:
            type: bucket
            rate: 1000
            capacity: 10000
        event-config:
          raw-output-policy: inline
        gc-interval: 12h
        kube-client-config:
          qps: 100
          burst: 25
          timeout: 30s
      webhook:
        certDir: /etc/webhook/certs
        serviceName: flyte-pod-webhook
      cache:
        max_size_mbs: 1024
        target_gc_percent: 70
      # -- For Workflow store use configuration [here](https://pkg.go.dev/github.com/flyteorg/flytepropeller/pkg/controller/workflowstore#Config)
      #

    enabled_plugins:
      # -- Tasks specific configuration [structure](https://pkg.go.dev/github.com/flyteorg/flytepropeller/pkg/controller/nodes/task/config#GetConfig)
      tasks:
        # -- Plugins configuration, [structure](https://pkg.go.dev/github.com/flyteorg/flytepropeller/pkg/controller/nodes/task/config#TaskPluginConfig)
        task-plugins:
          # -- [Enabled Plugins](https://pkg.go.dev/github.com/lyft/flyteplugins/go/tasks/config#Config). Enable sagemaker*, athena if you install the backend
          # plugins
          enabled-plugins:
            - container
            - echo
            - sidecar
            - k8s-array
          default-for-task-types:
            container: container
            sidecar: sidecar
            container_array: k8s-array

    # -- Kubernetes specific Flyte configuration
    k8s:
      plugins:
        # -- Configuration section for all K8s specific plugins [Configuration structure](https://pkg.go.dev/github.com/lyft/flyteplugins/go/tasks/pluginmachinery/flytek8s/config)
        k8s:
          default-cpus: 100m
          default-memory: 100Mi

    # -- Logger configuration
    logger:
      logger:
        show-source: true
        level: 4

    # -- Resource manager configuration
    resource_manager:
      # -- resource manager configuration
      propeller:
        resourcemanager:
          type: noop

    # -- Section that configures how the Task logs are displayed on the UI. This has to be changed based on your actual logging provider.
    # Refer to [structure](https://pkg.go.dev/github.com/lyft/flyteplugins/go/tasks/logs#LogConfig) to understand how to configure various
    # logging engines
    task_logs:
      plugins:
        logs:
          kubernetes-enabled: true
          # -- One option is to enable cloudwatch logging for EKS, update the region and log group accordingly
          cloudwatch-enabled: false

  # --------------------------------------------------------
  # Optional Plugins
  # --------------------------------------------------------

  # -- Optional: Spark Plugin using the Spark Operator
  sparkoperator:
    # --- enable or disable Sparkoperator deployment installation
    enabled: false

    # -- Spark plugin configuration
    plugin_config:
      plugins:
        spark:
          # -- Spark default configuration
          spark-config-default:
            - spark.driver.cores: "1"
            - spark.executorEnv.HTTP2_DISABLE: "true"
            - spark.hadoop.fs.AbstractFileSystem.s3.impl: "org.apache.hadoop.fs.s3a.S3A"
            - spark.hadoop.fs.AbstractFileSystem.s3a.impl: "org.apache.hadoop.fs.s3a.S3A"
            - spark.hadoop.fs.AbstractFileSystem.s3n.impl: "org.apache.hadoop.fs.s3a.S3A"
            - spark.hadoop.fs.s3.impl: "org.apache.hadoop.fs.s3a.S3AFileSystem"
            - spark.hadoop.fs.s3a.acl.default: "BucketOwnerFullControl"
            - spark.hadoop.fs.s3a.impl: "org.apache.hadoop.fs.s3a.S3AFileSystem"
            - spark.hadoop.fs.s3n.impl: "org.apache.hadoop.fs.s3a.S3AFileSystem"
            - spark.kubernetes.allocation.batch.size: "50"
            - spark.kubernetes.driverEnv.HTTP2_DISABLE: "true"
            - spark.network.timeout: 600s
            - spark.executorEnv.KUBERNETES_REQUEST_TIMEOUT: 100000
            - spark.executorEnv.AWS_METADATA_SERVICE_NUM_ATTEMPTS: 20
            - spark.executorEnv.AWS_METADATA_SERVICE_TIMEOUT: 5
            - spark.executor.heartbeatInterval: 60s
            - spark.ui.proxyRedirectUri: "{{.Values.cloudUrl}}"
            - spark.hadoop.fs.s3a.aws.credentials.provider: com.amazonaws.auth.WebIdentityTokenCredentialsProvider

  common:
    ingress:
      enabled: false
  objectStore:
    enabled: false
    replicaCount: &objectstore-minReplicaCount 1
    maxMessageSizeBytes: 104857600 # 100MB
    secrets:
      create: false
      mount: false
      redisAuthToken: ""
    bucket: "opencompute-staging-sample-tenant"
    redis:
      host: clustercfg.objectstore-staging.p7pazr.memorydb.us-east-2.amazonaws.com:6379
    service:
      httpPort: 8080
      grpcPort: 8089
    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Annotations to add to the service account
      annotations: { }
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""
    resources:
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      limits:
        cpu: "1"
        ephemeral-storage: 500Mi
        memory: "1Gi"
      requests:
        cpu: "100m"
        ephemeral-storage: 100Mi
        memory: "128Mi"
    autoscaling:
      enabled: false
      minReplicas: *objectstore-minReplicaCount
      maxReplicas: 5
      targetCPUUtilizationPercentage: 80
    livenessProbe:
      httpGet:
        path: /healthcheck
        port: debug
      initialDelaySeconds: 3
      periodSeconds: 3
    readinessProbe:
      httpGet:
        path: /healthcheck
        port: debug
      initialDelaySeconds: 3
      periodSeconds: 3

  proxy:
    prof-port: 10254
    replicaCount: &proxy-minReplicaCount 2
    service:
      port: 8080
    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Annotations to add to the service account
      annotations: { }
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    resources:
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      limits:
        cpu: "1"
        ephemeral-storage: 500Mi
        memory: "1Gi"
      requests:
        cpu: "100m"
        ephemeral-storage: 100Mi
        memory: "128Mi"

    podEnv:
      - name: GOMEMLIMIT
        valueFrom:
          resourceFieldRef:
            resource: limits.memory
      - name: GOMAXPROCS
        valueFrom:
          resourceFieldRef:
            resource: limits.cpu

    autoscaling:
      enabled: false
      minReplicas: *proxy-minReplicaCount
      maxReplicas: 100
      targetCPUUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage: 80

  # -----------------------------------------------------
  # Core dependencies that should be configured for Flyte to work on any platform
  # ------------------------------------------------------
  unionoperator:
    replicaCount: &unionoperator-minReplicaCount 1

    image:
      repository: public.ecr.aws/p0i0a9q8/unionoperator
      pullPolicy: IfNotPresent
      tag: 2024.12.2

    imagePullSecrets: []
    nameOverride: ""
    fullnameOverride: ""

    secretName: union-base

    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Automatically mount a ServiceAccount's API credentials?
      automount: true
      # Annotations to add to the service account
      annotations: { }
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    podAnnotations:
      prometheus.io/path: /metrics
      prometheus.io/port: "10254"
      prometheus.io/scrape: "true"

    podSecurityContext: { }
    #      fsGroup: 65534
    #      runAsUser: 1001
    #      fsGroupChangePolicy: "Always"

    securityContext: { }
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

    podEnv:
      - name: GOMEMLIMIT
        valueFrom:
          resourceFieldRef:
            resource: limits.memory
      - name: GOMAXPROCS
        valueFrom:
          resourceFieldRef:
            resource: limits.cpu

    service:
      type: ClusterIP
      port: 80

    resources:
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      limits:
        cpu: "4"
        ephemeral-storage: 500Mi
        memory: "8Gi"
      requests:
        cpu: "1"
        ephemeral-storage: 100Mi
        memory: "4Gi"

    autoscaling:
      enabled: false
      minReplicas: *unionoperator-minReplicaCount
      maxReplicas: 100
      targetCPUUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage: 80

    nodeSelector: { }

    tolerations: [ ]

    affinity: { }

    configmapOverrides: { }

    additionalLabels: { }

  unionoperatorSparkHistoryServer:
    enabled: false
    replicaCount: &unionoperatorSparkHistoryServer-minReplicaCount 1

    image:
      repository: ghcr.io/flyteorg/flytecookbook
      tag: k8s_spark-a3b97943563cfc952b5683525763578685a93694
      pullPolicy: IfNotPresent

    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Annotations to add to the service account
      annotations: { }
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    podSecurityContext: { }

    securityContext:
      allowPrivilegeEscalation: true
      runAsUser: 0

    service:
      type: ClusterIP
      port: 80

    resources:
      limits:
        cpu: "1"
        ephemeral-storage: 500Mi
        memory: "2Gi"
      requests:
        cpu: "100m"
        ephemeral-storage: 100Mi
        memory: "500Mi"

    autoscaling:
      enabled: false
      minReplicas: *unionoperatorSparkHistoryServer-minReplicaCount
      maxReplicas: 10
      targetCPUUtilizationPercentage: 80
      targetMemoryUtilizationPercentage: 80

    nodeSelector: { }

    tolerations: [ ]

    affinity: { }

    configmapOverrides: { }

    proxyHost: ""

  unionoperatorMonitoring:
    enabled: false
    prometheus:
      autoscaling:
        enabled: false

      replicaCount: 1

      externalUrl: /prometheus/

      storage:
        persistent: false
        className: gp2
        sizePerReplica: 1Gi
        retention:
          # size should strictly be less than the sizePerReplica in case of persistent, else less than ephemeral-storage
          size: 400MB

      resources:
        limits:
          cpu: "4"
          ephemeral-storage: 1Gi
          memory: "8Gi"
        requests:
          cpu: "1"
          ephemeral-storage: 500Mi
          memory: "500Mi"

      image:
        repository: prom/prometheus
        tag: v2.43.0
        pullPolicy: IfNotPresent

      serviceAccount:
        # Specifies whether a service account should be created
        create: true
        # Annotations to add to the service account
        annotations: { }
        # The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""

      podSecurityContext:
        fsGroup: 65534
        runAsNonRoot: true
        runAsUser: 65534

      securityContext:
        allowPrivilegeEscalation: false

      service:
        type: ClusterIP
        port: 80

      topologyKey: topology.kubernetes.io/zone

      cadvisor:
        metricsNameRegex:
          # cadvisor metrics for flyte executions
          default: container_cpu_usage_seconds_total|container_memory_working_set_bytes
          # cadvisor metrics for flyte executions and kube-system and union services
          extended: (container_spec_cpu_quota|container_spec_cpu_period|container_cpu_cfs_throttled_periods_total|container_cpu_cfs_periods_total|container_spec_memory_limit_bytes|container_fs_inodes_free|container_fs_inodes_total)

        # Additional metric_relabel_configs for cadvisor Prometheus jobs
        additional_metric_relabel_configs: []

    kubeStateMetrics:
      replicaCount: 1
      image:
        repository: registry.k8s.io/kube-state-metrics/kube-state-metrics
        # Ref: https://github.com/kubernetes/kube-state-metrics?tab=readme-ov-file#compatibility-matrix
        # Most Dataplanes are running 1.28, therefore pin to 2.11.0 kube-state-metrics
        tag: v2.11.0
        pullPolicy: IfNotPresent

      serviceAccount:
        # Specifies whether a service account should be created
        create: true
        # Annotations to add to the service account
        annotations: { }
        # The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""

      podSecurityContext: { }

      securityContext:
        allowPrivilegeEscalation: false

      service:
        type: ClusterIP
        port: 8080

      resources:
        limits:
          cpu: "4"
          ephemeral-storage: 500Mi
          memory: "8Gi"
        requests:
          cpu: "1"
          ephemeral-storage: 100Mi
          memory: "500Mi"

      autoscaling:
        enabled: false

    dcgmExporter:
      enabled: true
      image:
        repository: nvcr.io/nvidia/k8s/dcgm-exporter
        tag: 3.1.7-3.1.4-ubuntu20.04
        pullPolicy: IfNotPresent

      arguments: ["-f", "/etc/dcgm-exporter/dcp-metrics-included.csv"]
      serviceAccount:
        # Specifies whether a service account should be created
        create: true
        # Annotations to add to the service account
        annotations: { }
        # The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""

      podSecurityContext: { }

      securityContext:
        runAsNonRoot: false
        runAsUser: 0
        privileged: true
        capabilities:
          add: [ "SYS_ADMIN" ]

      service:
        type: ClusterIP
        port: 9400
        address: ":9400"
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: ami_type
                operator: In
                values:
                - AL2_x86_64_GPU
            - matchExpressions:
              - key: cloud.google.com/gke-accelerator
                operator: Exists
      tolerations:
        - effect: NoSchedule
          key: flyte.org/node-role
          operator: Exists
        - effect: NoSchedule
          key: nvidia.com/gpu
          operator: Exists
      resources:
        limits:
          ephemeral-storage: 500Mi
          memory: 400Mi
        requests:
          cpu: 100m
          ephemeral-storage: 500Mi
          memory: 128Mi
      kubeletPath: "/var/lib/kubelet/pod-resources"
      extraHostVolumes:
        - name: nvidia-install-dir-host
          hostPath: /home/kubernetes/bin/nvidia
      extraVolumeMounts:
        - name: nvidia-install-dir-host
          mountPath: /usr/local/nvidia
          readOnly: true
    flytePropeller:
      enabled: false
    opencost:
      enabled: false
      scrape: false
      alpha: false

    fluentbit:
      # Namespace to scrape for fluent-bit metrics
      namespace: kube-system
      # Label name=value to select the pod within the specified namespace
      kubernetesLabel: app.kubernetes.io/name=aws-for-fluent-bit

    scrapeConfigs:
      kubeStateMetrics:
        extraMetricRelabelConfigs: []
    extraScrapeConfigs: []

  kubePrometheusStack:
    enabled: true

  kubeeventmonitor:
    enabled: false
    # Name to be used for this specific component
    # Will be prefixed with union-operator generated name
    name: kubeeventmonitor

    # Log level from flyte/flytestdlib/config.go
    logLevel: 4 # 4 is info

    # This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
    replicaCount: 1

    # This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
    image:
      repository: public.ecr.aws/p0i0a9q8/unionoperator
      tag: "invalid-version"
      # This sets the pull policy for images.
      pullPolicy: IfNotPresent

    # Application specific configuration to filter for specific pods
    config:
      selectors: {}

    # Enable metrics scraping
    prometheus:
      enabled: true # Default to true
      path: /metrics
      port: 10254
      metricsNamespace: "kubeeventmonitor"

    # This is for the secretes for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    imagePullSecrets: []

    # This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Automatically mount a ServiceAccount's API credentials?
      automount: true
      # Annotations to add to the service account
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    # This is for setting Kubernetes Annotations to a Pod.
    # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    podAnnotations: {}
    # This is for setting Kubernetes Labels to a Pod.
    # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    podLabels: {}

    podSecurityContext: {}
      # fsGroup: 2000

    securityContext: {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000

    resources:
      # -- Requests are the minimum set of resources needed for this pod
      requests:
        cpu: 10m
        memory: 128Mi
      # -- Limits are the maximum set of resources needed for this pod
      limits:
        cpu: 200m
        memory: 256Mi

    # This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
    livenessProbe: {}
      # httpGet:
      #   path: /
      #   port: http
    readinessProbe: {}
      # httpGet:
      #   path: /
      #   port: http

    # This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
    autoscaling:
      enabled: false
      minReplicas: 1
      maxReplicas: 100
      targetCPUUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage: 80

    # Additional volumes on the output Deployment definition.
    volumes: []
    # - name: foo
    #   secret:
    #     secretName: mysecret
    #     optional: false

    # Additional volumeMounts on the output Deployment definition.
    volumeMounts: []
    # - name: foo
    #   mountPath: "/etc/foo"
    #   readOnly: true

    nodeSelector: {}

    tolerations: []

    affinity: {}

  computeResourceManager:
    enabled: false
    type: ""

opencost:
  # Values documented at https://github.com/opencost/opencost-helm-chart/tree/main/charts/opencost
  fullnameOverride: opencost
  opencost:
    # By default, disable prometheus. This runs opencost in exporter mode: https://www.opencost.io/docs/opencost-exporter
    # Set internal or external values to populate the PROMETHEUS_SERVER_ENDPOINT env var
    prometheus:
      external:
        enabled: false
      internal:
        enabled: false

    ui:
      enabled: false
    exporter:
      resources:
        requests:
          cpu: 500m
          memory: 500Mi
        limits:
          cpu: 1000m
          memory: 2Gi

minio:
  # -- Replicas count for Minio deployment
  replicaCount: 1
  image:
    # -- Docker image for Minio deployment
    repository: ecr.flyte.org/bitnami/minio
    # -- Docker image tag
    tag: 2021.10.13-debian-10-r0
    # -- Docker image pull policy
    pullPolicy: IfNotPresent
  # -- Default resources requests and limits for Minio deployment
  resources:
    # -- Requests are the minimum set of resources needed for this pod
    requests:
      cpu: 10m
      memory: 128Mi
    # -- Limits are the maximum set of resources needed for this pod
    limits:
      cpu: 200m
      memory: 512Mi
  # -- Service settings for Minio
  service:
    annotations: { }
    type: ClusterIP
  # -- Annotations for Minio pods
  podAnnotations: { }
  # -- nodeSelector for Minio deployment
  nodeSelector: { }
  # -- tolerations for Minio deployment
  tolerations: [ ]
  # -- affinity for Minio deployment
  affinity: { }
  persistence:
    enabled: false
    persistentVolumeClaimName: ""

#
# FLYTE_AGENT SETTINGS
#

flyteagent:
  enabled: false
  # -- Replicas count for flyteagent deployment
  replicaCount: 2
  image:
    # -- Docker image for flyteagent deployment
    repository: ghcr.io/unionai/flyte-conformance-agent
    # -- Docker image tag
    # https://github.com/unionai/flyte-conformance/blob/main/mock_agent/Dockerfile
    # https://github.com/unionai/flyte-conformance/pkgs/container/flyte-conformance-agent
    tag: cec690330a330bfd68b4e68215676fb994b32796
    # -- Docker image pull policy
    pullPolicy: IfNotPresent
  ports:
    containerPort: 8000
    name: agent-grpc
  prometheusPort:
    containerPort: 9090
    name: agent-metric
  # -- Default resources requests and limits for flyteagent deployment
  resources:
    limits:
      cpu: "1.5"
      ephemeral-storage: 100Mi
      memory: 1500Mi
    requests:
      cpu: "1"
      ephemeral-storage: 100Mi
      memory: 1000Mi
  # -- Default glob string for searching configuration files
  configPath: /etc/flyteagent/config/*.yaml
  # -- Service settings for flyteagent
  service:
    type: ClusterIP
    # Use headless service for flyteagent
    clusterIP: None
  # -- Configuration for service accounts for flyteagent
  serviceAccount:
    # -- Should a service account be created for flyteagent
    create: true
    # -- Annotations for ServiceAccount attached to flyteagent pods
    annotations: {}
    # -- ImagePullSecrets to automatically assign to the service account
    imagePullSecrets: []
  # -- Annotations for flyteagent pods
  podAnnotations: {}
  # -- nodeSelector for flyteagent deployment
  nodeSelector: {}
  # -- tolerations for flyteagent deployment
  tolerations: []
  # -- affinity for flyteagent deployment
  affinity: {}
  # -- Appends additional volumes to the deployment spec. May include template values.
  additionalVolumes: []
  # -- Appends additional volume mounts to the main container's spec. May include template values.
  additionalVolumeMounts: []
  # -- Appends additional containers to the deployment spec. May include template values.
  additionalContainers: []
  # -- Appends additional envs to the deployment spec. May include template values
  additionalEnvs: []
  # -- Appends extra command line arguments to the main command
  extraArgs: {}
  # -- Sets priorityClassName for datacatalog pod(s).
  priorityClassName: ""

  autoscaling:
    minReplicas: 2
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

dgxagent:
  enabled: false
  # -- Replicas count for flyteagent deployment
  replicaCount: 2
  image:
    # -- Docker image for flyteagent deployment
    repository: ghcr.io/unionai/dgx-agent
    # -- Docker image tag
    tag: v1
    # -- Docker image pull policy
    pullPolicy: Always
  ports:
    containerPort: 8000
    name: agent-grpc
  prometheusPort:
    containerPort: 9090
    name: agent-metric
  # -- Default resources requests and limits for flyteagent deployment
  resources:
    limits:
      cpu: "1.5"
      ephemeral-storage: 100Mi
      memory: 3000Mi
    requests:
      cpu: "1"
      ephemeral-storage: 100Mi
      memory: 2000Mi
  # -- Default glob string for searching configuration files
  configPath: /etc/flyteagent/config/*.yaml
  # -- Service settings for flyteagent
  service:
    type: ClusterIP
    # Use headless service for flyteagent
    clusterIP: None
  # -- Configuration for service accounts for flyteagent
  serviceAccount:
    # -- Should a service account be created for flyteagent
    create: true
    # -- Annotations for ServiceAccount attached to flyteagent pods
    annotations: {}
    # -- ImagePullSecrets to automatically assign to the service account
    imagePullSecrets: []
  # -- Annotations for flyteagent pods
  podAnnotations: {}
  # -- nodeSelector for flyteagent deployment
  nodeSelector: {}
  # -- tolerations for flyteagent deployment
  tolerations: []
  # -- affinity for flyteagent deployment
  affinity: {}
  # -- Appends additional volumes to the deployment spec. May include template values.
  additionalVolumes: []
  # -- Appends additional volume mounts to the main container's spec. May include template values.
  additionalVolumeMounts: []
  # -- Appends additional containers to the deployment spec. May include template values.
  additionalContainers: []
  # -- Appends additional envs to the deployment spec. May include template values
  additionalEnvs: []
  # -- Appends extra command line arguments to the main command
  extraArgs: {}
  # -- Sets priorityClassName for datacatalog pod(s).
  priorityClassName: ""

  autoscaling:
    minReplicas: 2
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

taskNamespaceNetworkPolicy:
  # -- Enables a global network policy for task namespaces
  enabled: false
  # -- Selector for task namespaces
  selector: union.ai/namespace-type == "flyte"
  # -- Blocks pods in task namespaces from accessing internal IPs other than kube-dns and union-operator namespace
  blockInternalIPs: true
  # -- Blocks pods in task namespaces from accessing metadata server and from retrieving cloud provider credentials
  blockIMDS: true

kube-prometheus-stack:
  fullnameOverride: metrics
  # kube-prometheus-stack
  #
  # Installed after Union Operator managed Prometheus. Can be used to decouple Prometheus and related services
  # from Union Operator helm chart.
  #
  # Reference: https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack

  ## Setting to true produces cleaner custom resource names
  cleanPrometheusOperatorObjectNames: true

  ## Labels to apply to all resources
  ##
  commonLabels: {}

  ## Do not use this Helm chart to install CRDs. This would force us to update CRDs manually as
  ## we upgrade this Helm chart.
  ##
  ## Instead install the prometheus-operator-crd specific helm chart as sibling to this chart
  ## https://github.com/prometheus-community/helm-charts/tree/main/charts/prometheus-operator-crds
  crds:
    enabled: false

  ## Create default rules for monitoring the cluster
  ##
  # We can utilize useful pre-built queries incrementally as to pace
  # the introduction of more unique time series
  defaultRules:
    create: false

  ## Provide custom recording or alerting rules to be deployed into the cluster.
  ##
  additionalPrometheusRulesMap: {}
  #  rule-name:
  #    groups:
  #    - name: my_group
  #      rules:
  #      - record: my_record
  #        expr: 100 * my_record

  ##
  # Enable when we enable Prometheus services from
  global:
    rbac:
      create: false

  ## Components to Enable once we migrate to using Prometheus Operator
  #

  # Flag to disable all component scrapers
  kubernetesServiceMonitors:
    enabled: false
  kubeApiServer: ## Component scraping the kube api server
    enabled: false
  kubelet:
    enabled: false
  kubeControllerManager:
    enabled: false
  coreDns:
    enabled: false
  # # Should never have to enable as GCP and AWS use CoreDNS
  # kubeDns:
  #   enabled: false
  kubeEtcd:
    enabled: false
  kubeScheduler:
    enabled: false
  kubeProxy:
    enabled: false
  kubeStateMetrics:
    enabled: false
  ##
  # Configuration for kube-state-metrics subchart
  # Reference: https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-state-metrics
  #
  # kube-state-metrics:
  #   ...

  ## Deploy node exporter as a daemonset to all nodes
  ##
  nodeExporter:
    enabled: true
    operatingSystems:
      linux:
        enabled: true
      darwin:
        enabled: false

  ##
  # Configuration for prometheus-node-exporter subchart
  # Reference: https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus-node-exporter/values.yaml
  prometheus-node-exporter:
    # Place in Kube-system as a critical system component with high priority
    namespaceOverride: kube-system
    priorityClassName: system-node-critical
    updateStrategy:
      type: RollingUpdate
      rollingUpdate:
        maxUnavailable: 25%
    extraArgs:
      - --collector.filesystem.mount-points-exclude=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/.+)($|/)
      - --collector.filesystem.fs-types-exclude=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs|tmpfs)$
      - --no-collector.arp
      - --no-collector.bonding
      - --no-collector.btrfs
      - --no-collector.cpufreq
      - --no-collector.edac
      - --no-collector.ethtool
      - --no-collector.entropy
      - --no-collector.fibrechannel
      - --no-collector.filefd
      - --no-collector.hwmon
      - --no-collector.infiniband
      - --no-collector.ipvs
      - --no-collector.nfs
      - --no-collector.nfsd
      - --no-collector.powersupplyclass
      - --no-collector.rapl
      - --no-collector.schedstat
      - --no-collector.sockstat
      - --no-collector.softnet
      - --no-collector.textfile
      - --no-collector.thermal_zone
      - --no-collector.timex
      - --no-collector.udp_queues
      - --no-collector.mdadm
      - --collector.conntrack # Required for tracking conntrack limits.
    resources:
      limits:
        cpu: 50m
        memory: 100Mi
      requests:
        cpu: 10m
        memory: 10Mi
    prometheus:
      monitor:
        enabled: false # Leave disabled
      podMonitor:
        enabled: false # Enable when Prometheus Operator is enabled

  ##
  ## Manages Prometheus and Alertmanager components
  ## Reference(s):
  ## * https://github.com/prometheus-operator/prometheus-operator
  ## * https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack/templates/prometheus-operator
  prometheusOperator:
    enabled: false # Enable when ready to have Prometheus Operator ready to manage Prometheus instances

    ## Number of old replicasets to retain ##
    # revisionHistoryLimit: 5

    ## Create a servicemonitor for the operator
    ##
    # serviceMonitor:
    #   selfMonitor: true

    ## Resource limits & requests
    ##
    # resources:
    #   limits:
    #     cpu: 200m
    #     memory: 200Mi
    #   requests:
    #     cpu: 100m
    #     memory: 100Mi

  ## Deploy a Prometheus instance
  ##
  prometheus:
    enabled: false # Enable when ready to switch from Union Operator managed Prometheus.

    ## Have Helm chart provision service account for least privelige access.
    ## Can change if Kubernetes service account needs access to AWS or GCP resources.
    ##
    ## Service account for Prometheuses to use.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
    ##
    # serviceAccount:
    #   create: true
    #   name: ""
    #   annotations: {}

    ## Configure pod disruption budgets for Prometheus
    ## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/#specifying-a-poddisruptionbudget
    ## This configuration is immutable once created and will require the PDB to be deleted to be changed
    ## https://github.com/kubernetes/kubernetes/issues/45398
    ##
    # podDisruptionBudget:
    #   enabled: true
    #   minAvailable: 1

    # Enable monitoring of Prometheus through Prometheus Operator
    # serviceMonitor:
    #   selfMonitor: false

    ##
    # Prometheus CRD Spec,
    # Would have to do a methodical migration from Union Prometheus if desired
    #
    ## Settings affecting prometheusSpec
    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#prometheusspec
    ##
    # prometheusSpec:
      # ...

  ## Services to never deploy to Data Planes NOT deploy
  alertmanager:
    enabled: false
  grafana:
    enabled: false

serving:
  # -- Enables the serving component. Installs Knative Serving. Knative-Operator must be running in the cluster for this to work.
  enabled: false
  # -- The number of replicas to create for all components for high availability.
  replicas: 2
  # -- Enables scraping of metrics from the serving component
  metrics: false

kueue-resources:
  enabled: false
